<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Remark</title>
    <link rel="stylesheet" type="text/css" href="../remark-theme-dark.css" />
    <script src="../remark-0.4.2.min.js" type="text/javascript">
      {"highlightStyle": "monokai"}
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine();
    </script>
  </head>
  <body>
<textarea id="source">
name: inverse
layout: true
class: inverse
---
class: center middle
# Rails for Legacy Database
[greatghoul]
---
class: center middle
## Convention Over Configuration
然后，有时你不得去面对一些发酵的配置，比如，遗留数据库...
---
## 背景

### - 老数据库
### - 不能修改
### - 命名不规范
### - 大量冗余
### - 自定规则主键
---
## 那么遗留数据库有哪些痛

### - **表名的差异**
### - 主键的差异
### - 时间戳的差异
### - 实体关系

---
## 表名的差异

不同的 ``DBA`` 数据库表的命名方式真的千差万别

    create table driver(...);
    create table order_detail(...);
    create table person(...);

而 ``Rails`` 默认是这样

    Driver ................ drivers
    OrderDetail ..... order_details
    Person ................ people

**其它**：表前缀(如 ``wp_``) 或后缀 (如 ``_tb``)

这里且不论哪种表名更加**优雅**，``Rails`` 很方便，但它显然不能适应所有 ``DBA`` 的哲学，所以默认规则这里显然是不能用了。
---
## 表名的差异 - 实践
.left-column[
### - 少量单数
]
.right-column[
如果数据库中只有少数表名为单数模式，则可以单独在 migrate 时做修改。

``migration`` 

    class CreateGroups < ActiveRecord::Migration
      def change
        create_table :groups do |t|
            # ...
        end
      end
      rename_table :groups, :group
    end

或者

    create_table :group do |t|
        # ...
    end
    
``model``

    class Group < ActiveRecord::Base
      self.table_name = 'group'
      # attr_accessible .... 
    end      
    
]
---
## 表名的差异 - 实践
.left-column[
### - 少量单数
### - 大量单数
]
.right-column[
如果大部分的表都为单数，就没有必要逐个修改表名，rails 提供了统一的[配置方法](http://guides.rubyonrails.org/configuring.html#configuring-active-record)，来自动生成单数表名，对于个别复数或者不规则的情况，可能参考上一切的方法修改。

``config/application.rb``

    class Application < Rails::Application
       # ...
       config.active_record.pluralize_table_names = false 
    end

设置为单数模式后 generator 会自动生成单数表名

    rails g model Customer name:string

生成的 migrate  

    class CreateCustomer < ActiveRecord::Migration
      def change
        create_table :customer do |t|
          t.string :name

          t.timestamps
        end
      end
    end

]
---
## 表名的差异 - 实践
.left-column[
### - 少量单数
### - 大量单数  
### - 前缀后缀
]
.right-column[
Wordpress 及一些 CMS 会有表名前缀或者后缀的规则

``config/application.rb``

    class Application < Rails::Application
      # ...
      config.active_record.table_name_prefix = 'foo_'
      config.active_record.table_name_suffix = '_bar'
    end

执行

    $ rails g modal Detail name:string

    # migration output
    create_table :details do |t|
      t.string :name
      # ...
    end
    
    # database output
    create table foo_details_bar ( ... );

前后缀作用于全局，但可在 model 中显式指定表名绕过规则。

    self.table_name = 'details'
]
---
## 那么遗留数据库有哪些痛

### - 表名的差异
### - **主键的差异**
### - 时间戳的差异
### - 实体关系
---
## 主键的差异

### 命名

``detail_id``, ``id``  

### 类型

字符型：UUID、按规则拼接  
复合型：复合主键

---
## 主键的差异 - 实践
.left-column[

### - 名称差异 

]
.right-column[
`migration` 

    class CreateDetails < ActiveRecord::Migration
      def change
        create_table :details, :primary_key => :detail_id do |t|
          # attributes ...
        end
        # ... 
      end
    end
    
`model`

    class Detail < ActiveRecord::Base
      # ...
      self.primary_key = :detail_id
      alias_attribute :detail_id, :id
      # attr_accessible .... 
    end      
    
]
---
## 主键的差异 - 实践
.left-column[

### - 名称差异 
### - 类型差异 

]
.right-column[
非默认类型主键无法识别

`migration` 

    class CreateDetails < ActiveRecord::Migration
      def change
        create_table :details, :id => false do |t|
          t.string, :code, :limit => 36
          # attributes ...
        end
        execute 'ALTER TABLE details ADD PRIMARY KEY(code);'
        # ... 
      end
    end
    
_根据数据库的不同，这里设置主键的语句会有变化_

`model`

    class Detail < ActiveRecord::Base
      # ..
      self.primary_key = :code
      # attr_accessible .... 
    end      
    
]
---
## 主键的差异 - 实践
.left-column[

### - 名称差异 
### - 类型差异 
### - UUID 

]
.right-column[
``lib/extras/uuid_helper.rb``

    require 'rubygems'
    require 'uuidtools'

    module UUIDHelper
      def self.included(base)
        base.class_eval do
          before_create :set_guuid

          def set_guuid
            self.code = UUIDTools::UUID.random_create.to_s
          end
        end
      end
    end

``config/application.rb``

    config.autoload_paths += %W(#{config.root}/extras)
    
``model``

    class Ietail < ActiveRecord::Base
      include UUIDHelper
      # attr_accessible .... 
    end      
]
---
## 主键的差异 - 实践
.left-column[

### - 名称差异 
### - 类型差异 
### - UUID 

]
.right-column[

`model`

    class Ietail < ActiveRecord::Base
      include UUIDHelper
      # attr_accessible .... 
    end      
]
---
## 那么遗留数据库有哪些痛

### - 表名的差异
### - 主键的差异
### - **时间戳的差异**
### - 实体关系
---
## 时间戳的差异

Rails默认时间戳

    created_at, updated_at

公司数据库中的时间戳

    created_date, last_modified_date

**解决方法**

``config/initializers/active_record.rb``

    module ActiveRecord
      module Timestamp      
        private
        def timestamp_attributes_for_update #:nodoc:
          [:last_modified_date, :updated_at, :updated_on, :modified_at]
        end
        def timestamp_attributes_for_create #:nodoc:
          [:create_date, :created_at, :created_on]
        end      
      end
    end
---
## 那么遗留数据库有哪些痛

### - 表名的差异
### - 主键的差异
### - 时间戳的差异
### - **实体关系**
---
## 实体关系

 ...
---
## 参考资料

 * [Universally Unique Identifier, UUID](http://zh.wikipedia.org/wiki/UUID)
 * [Ruby and Rails Naming Conventions](http://itsignals.cascadia.com.au/?p=7)

---
name: last-page
template: inverse

## That's all folks (for now)!

Slideshow created using [remark](http://github.com/gnab/remark).

</textarea>
<div id="slideshow"></div>
</body>
</html>
<!-- 
vim:ft=markdown
-->
